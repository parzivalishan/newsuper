<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiSender on Multiple Networks</title>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"></script>
    <link rel="icon" href="https://raw.githubusercontent.com/parzivalishan/newsuper/main/assets/superchain.png" type="image/png">
    <style>
        /* Your existing CSS styles */
        body {
            background-color: #0B0C0E;
            color: wheat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        h1, h3 {
            margin: 10px 0;
        }

        button, textarea, input {
            margin: 10px 0;
            padding: 10px;
            width: 300px;
            border: none;
            border-radius: 5px;
        }

        button {
            background-color: #8a2be2;
            color: white;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #7b1fa2;
        }

        button:active {
            background-color: #6a1b9a;
        }

        button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.5);
        }

        textarea {
            height: 150px;
            width: 500px;
            resize: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #e6f7e6;
        }

        .send-options-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .send-options-wrapper h3 {
            margin: 0;
            color: white;
        }

        .option-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            background-color: #1e1e1e;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .option-container:hover {
            border-color: #8a2be2;
            background-color: #2a2a2a;
        }

        .radio-container {
            position: relative;
            margin: 0 10px;
            padding: 10px;
            border-radius: 5px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .radio-container input {
            display: none;
        }

        .radio-label {
            cursor: pointer;
            padding: 10px 20px;
            background-color: #343a40;
            border: 1px solid #444;
            border-radius: 5px;
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }

        .radio-container input:checked+.radio-label {
            background-color: #8a2be2;
            color: white;
            border-color: #8a2be2;
            transform: translateY(-4px);
            box-shadow: 0 6px 12px rgba(138, 43, 226, 0.3);
        }

        .radio-container:hover .radio-label {
            background-color: #444;
            border-color: #8a2be2;
        }

        .contract-address-container {
            display: block;
            margin-top: 10px;
            width: 100%;
            max-width: 500px;
            background: #0B0C0E;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            box-sizing: border-box;
        }

        #contractAddress {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #e6f7e6;
            color: #333;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            box-sizing: border-box;
        }

        #contractAddress:hover, #contractAddress:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }

        header {
            background-color: #0B0C0E;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #connectWallet {
            font-weight: bold;
            font-size: 16px;
            background-color: #8a2be2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #connectWallet:hover {
            background-color: #7b1fa2;
        }

        .network-select-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .network-select-container label {
            margin-right: 10px;
            color: white;
            font-weight: bold;
        }

        .custom-dropdown {
            position: relative;
            display: inline-block;
            width: 200px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #1e1e1e;
            cursor: pointer;
        }

        .selected-option {
            display: flex;
            align-items: center;
            padding: 8px;
            color: white;
        }

        .selected-option img {
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }

        .dropdown-options {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background-color: #1e1e1e;
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 5px 5px;
            z-index: 1000;
        }

        .dropdown-option {
            display: flex;
            align-items: center;
            padding: 8px;
            color: white;
        }

        .dropdown-option:hover {
            background-color: #2a2a2a;
        }

        .dropdown-option img {
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        .modal.active-overlay {
            background-color: rgba(0, 0, 0, 0.9);
        }

        .modal-content {
            background-color: #0b0e0c;
            margin: 20% auto;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 400px;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover, .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .success {
            color: wheat;
        }

        .error {
            color: #FF0000;
        }

        .bold-italic {
            font-weight: bold;
            font-style: italic;
            text-align: center;
        }

        .modal-content button {
            margin-top: 10px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>

<body>
    <header style="background-color: #0B0C0E; padding: 5px 10px; display: flex; justify-content: space-between; align-items: center; width: 100%; position: fixed; top: 0; left: 0; z-index: 1000;">
        <button id="connectWallet" style="font-weight: bold; font-size: 16px; background-color: #8a2be2; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin: 0;">
            Connect Wallet
        </button>
    </header>

    <div class="network-select-container" style="margin-top: 50px;">
        <label for="networkSelect">Select Network:</label>
        <div class="custom-dropdown">
            <div class="selected-option">
                <img id="selectedNetworkImage" src="" alt="Network Logo">
                <span id="selectedNetworkName">Loading...</span>
            </div>
            <div class="dropdown-options" id="dropdownOptions">
                <!-- Options will be populated dynamically -->
            </div>
        </div>
    </div>

    <p id="walletAddress"></p>

    <div class="send-options-wrapper">
        <h3>Send:</h3>
        <div class="option-container">
            <div class="radio-container">
                <input type="radio" id="sendEther" name="sendOption" value="ether">
                <label for="sendEther" class="radio-label">
                    <img src="https://raw.githubusercontent.com/parzivalishan/newsuper/5f9711105cc92983d0ea9f3d0066c8a3fb30be3a/assets/eth-logo.svg" alt="Ether Logo" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 5px;">
                    <span style="color: white;">Ether</span>
                </label>
            </div>
            <div class="radio-container">
                <input type="radio" id="sendToken" name="sendOption" value="token" checked>
                <label for="sendToken" class="radio-label" style="color: white;">Tokens</label>
            </div>
        </div>
    </div>

    <div class="contract-address-container" id="contractAddressContainer">
        <input type="text" id="contractAddress" placeholder="Enter token contract address" class="bold-italic" />
    </div>

    <h3 style="margin-top: 20px; border-top: 1px solid #444; padding-top: 10px; color: white;">
        Recipients and Amounts
    </h3>
    <p>Enter one address and amount in ETH on each line. Supports any format:</p>
    <textarea id="recipientsAndAmounts" placeholder="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 3.141592 0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe,2.7182 0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9=1.42069"></textarea><br>

    <button id="disperseBtn" style="font-weight: bold; font-size: 16px;" data-clicked="false">Disperse Tokens</button>

    <div id="customAlert" class="modal" style="display:none;">
        <div class="modal-content">
            <span class="close-button" style="display: none;" onclick="closeModal()">×</span>
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
            <button onclick="handleModalAction()" style="display:none;">OK</button>
        </div>
    </div>
    <input type="hidden" id="currentChainId">
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let networks = {};
            let web3;
            let account;
            let contract;
            let connectedAccount;
            const disperseButton = document.getElementById('disperseBtn');
            let isConnecting = false;
            let currentNetwork = null;

            const contractABI = [
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "token",
                            "type": "address"
                        },
                        {
                            "name": "recipients",
                            "type": "address[]"
                        },
                        {
                            "name": "values",
                            "type": "uint256[]"
                        }
                    ],
                    "name": "disperseTokenSimple",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "token",
                            "type": "address"
                        },
                        {
                            "name": "recipients",
                            "type": "address[]"
                        },
                        {
                            "name": "values",
                            "type": "uint256[]"
                        }
                    ],
                    "name": "disperseToken",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "recipients",
                            "type": "address[]"
                        },
                        {
                            "name": "values",
                            "type": "uint256[]"
                        }
                    ],
                    "name": "disperseEther",
                    "outputs": [],
                    "payable": true,
                    "stateMutability": "payable",
                    "type": "function"
                }
            ];

            const tokenABI = [
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "_owner",
                            "type": "address"
                        }
                    ],
                    "name": "balanceOf",
                    "outputs": [
                        {
                            "name": "balance",
                            "type": "uint256"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "_spender",
                            "type": "address"
                        },
                        {
                            "name": "_value",
                            "type": "uint256"
                        }
                    ],
                    "name": "approve",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ];

            // Fetch network configurations from GitHub JSON file
            async function fetchNetworks() {
                try {
                    const response = await fetch('https://raw.githubusercontent.com/parzivalishan/newsuper/refs/heads/main/assets/networks.json');
                    const data = await response.json();
                    networks = data.networks;

                    // Set the default network to the first network in the JSON file
                    const firstNetworkKey = Object.keys(networks)[0];
                    currentNetwork = firstNetworkKey;

                    // Update the UI to reflect the default network
                    updateSelectedNetworkUI(firstNetworkKey, networks[firstNetworkKey].imageUrl);
                    populateDropdownOptions();
                } catch (error) {
                    console.error('Error fetching networks:', error);
                    openModal("Error", "Failed to load network configurations. Please try again later.", "error");
                }
            }

            // Update the selected network UI
            function updateSelectedNetworkUI(networkKey, imageUrl) {
                const selectedNetworkImage = document.getElementById('selectedNetworkImage');
                const selectedNetworkName = document.getElementById('selectedNetworkName');

                if (selectedNetworkImage && selectedNetworkName) {
                    selectedNetworkImage.src = imageUrl;
                    selectedNetworkName.textContent = networkKey;
                } else {
                    console.error('Selected network elements not found in the DOM.');
                }
            }

            // Populate dropdown options dynamically
            function populateDropdownOptions() {
                const dropdownOptions = document.getElementById('dropdownOptions');
                if (!dropdownOptions) {
                    console.error('Dropdown options element not found in the DOM.');
                    return;
                }

                dropdownOptions.innerHTML = '';

                for (const networkKey in networks) {
                    const network = networks[networkKey];
                    const option = document.createElement('div');
                    option.className = 'dropdown-option';
                    option.setAttribute('data-value', networkKey);
                    option.onclick = () => selectOption(networkKey, network.imageUrl, networkKey);
                    option.innerHTML = `<img src="${network.imageUrl}" alt="${networkKey}"><span>${networkKey}</span>`;
                    dropdownOptions.appendChild(option);
                }
            }

            // Function to handle network selection
            function selectOption(value, imageSrc, text) {
                currentNetwork = value;
                updateSelectedNetworkUI(value, imageSrc);
                updateContract();

                // Close the dropdown after selection
                const dropdownOptions = document.getElementById('dropdownOptions');
                if (dropdownOptions) {
                    dropdownOptions.style.display = 'none';
                }
            }

            // Update the contract instance based on the selected network
            function updateContract() {
                const selectedConfig = networks[currentNetwork];
                contract = new web3.eth.Contract(contractABI, selectedConfig.contractAddress);
            }

            // Initialize the application
            async function initializeApp() {
                await fetchNetworks();

                if (typeof window.ethereum !== 'undefined') {
                    web3 = new Web3(window.ethereum);
                    updateContract();

                    try {
                        const chainId = await ethereum.request({
                            method: 'eth_chainId'
                        });
                        document.getElementById('currentChainId').value = chainId;
                        await checkAndAutoSelectNetwork(chainId);
                    } catch (error) {
                        console.log('Couldnt get the chain id', error);
                    }
                } else {
                    alert("Please install MetaMask to use this feature.");
                }
            }

            // Check and auto-select the network based on the chain ID
            async function checkAndAutoSelectNetwork(chainId) {
                let selectedNetworkValue = null;

                for (const networkKey in networks) {
                    if (networks[networkKey].chainId === chainId) {
                        selectedNetworkValue = networkKey;
                        break;
                    }
                }

                if (selectedNetworkValue) {
                    const selectedOption = document.querySelector(".selected-option");
                    selectedOption.innerHTML = `<img src="${networks[selectedNetworkValue].imageUrl}" alt="${selectedNetworkValue}"><span>${selectedNetworkValue}</span>`;
                    updateContract();
                }
                await checkAndSwitchNetwork();
            }

            // Check and switch to the selected network
            async function checkAndSwitchNetwork() {
                const selectedConfig = networks[currentNetwork];
                const chainId = await ethereum.request({
                    method: 'eth_chainId'
                });

                if (chainId !== selectedConfig.chainId) {
                    try {
                        // First, try to switch to the network
                        await ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: selectedConfig.chainId }],
                        });
                    } catch (switchError) {
                        // If the network is not added, add it
                        if (switchError.code === 4902) {
                            try {
                                await ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: selectedConfig.chainId,
                                        chainName: selectedConfig.chainName,
                                        rpcUrls: selectedConfig.rpcUrls,
                                        nativeCurrency: {
                                            name: 'ETH',
                                            symbol: 'ETH',
                                            decimals: 18,
                                        },
                                        blockExplorerUrls: selectedConfig.blockExplorerUrls,
                                    }],
                                });

                                // After adding, try switching again
                                await ethereum.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: selectedConfig.chainId }],
                                });
                            } catch (addError) {
                                console.error('Could not add the network:', addError);
                                openModal("Error", "Failed to add the network. Please add it manually in MetaMask.", "error");
                            }
                        } else {
                            console.error('Could not switch to the network:', switchError);
                            openModal("Error", "Failed to switch network. Please try again.", "error");
                        }
                    }
                }
            }

            // Connect wallet button handler
            document.getElementById('connectWallet').onclick = async () => {
                if (isConnecting) {
                    return;
                }

                isConnecting = true;

                try {
                    await checkAndSwitchNetwork();
                    const accounts = await ethereum.request({
                        method: 'eth_requestAccounts'
                    });
                    if (accounts.length > 0) {
                        connectedAccount = accounts[0];
                        localStorage.setItem('connectedAccount', connectedAccount);
                        updateUI(connectedAccount);
                    } else {
                        localStorage.removeItem('connectedAccount');
                        document.getElementById('connectWallet').textContent = 'Connect Wallet';
                        document.getElementById('connectWallet').disabled = false;
                        document.getElementById('walletAddress').textContent = 'Not Connected';
                    }
                } catch (error) {
                    console.error("Error connecting to wallet:", error);
                    openModal("Error", "Failed to connect to wallet. Please try again.", "error");
                } finally {
                    isConnecting = false;
                }
            };

            // Update the UI with the connected wallet address
            const updateUI = async (connectedAccount) => {
                const shortAddress = `${connectedAccount.slice(0, 10)}...${connectedAccount.slice(-8)}`;
                const connectButton = document.getElementById('connectWallet');
                connectButton.textContent = shortAddress;
                connectButton.disabled = true;
                document.getElementById('walletAddress').textContent = `Connected: ${connectedAccount}`;
            };

            // Check for connected account on page load
            async function checkConnectedAccount() {
                const connectedAccount = localStorage.getItem('connectedAccount');
                if (connectedAccount) {
                    const accounts = await ethereum.request({
                        method: 'eth_accounts'
                    });
                    if (accounts.length > 0 && accounts[0] === connectedAccount) {
                        updateUI(connectedAccount);
                    } else {
                        localStorage.removeItem('connectedAccount');
                    }
                }
            }

            // Handle account changes
            ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    localStorage.removeItem('connectedAccount');
                    document.getElementById('connectWallet').textContent = 'Connect Wallet';
                    document.getElementById('connectWallet').disabled = false;
                    document.getElementById('walletAddress').textContent = 'Not Connected';
                } else {
                    connectedAccount = accounts[0];
                    localStorage.setItem('connectedAccount', connectedAccount);
                    updateUI(connectedAccount);
                }
            });

            // Handle chain changes
            ethereum.on('chainChanged', async (chainId) => {
                console.log('Chain changed to:', chainId);

                const selectedNetworkValue = Object.keys(networks).find(
                    networkKey => networks[networkKey].chainId === chainId
                );

                console.log('Matched network:', selectedNetworkValue);

                if (selectedNetworkValue) {
                    const selectedOption = document.querySelector(".selected-option");
                    selectedOption.innerHTML = `<img src="${networks[selectedNetworkValue].imageUrl}" alt="${selectedNetworkValue}"><span>${selectedNetworkValue}</span>`;
                    updateContract();
                }

                document.getElementById('currentChainId').value = chainId;
                localStorage.removeItem('connectedAccount');
                document.getElementById('connectWallet').textContent = 'Connect Wallet';
                document.getElementById('connectWallet').disabled = false;
                document.getElementById('walletAddress').textContent = 'Not Connected';

                try {
                    const accounts = await ethereum.request({
                        method: 'eth_accounts'
                    });
                    if (accounts.length > 0) {
                        connectedAccount = accounts[0];
                        localStorage.setItem('connectedAccount', connectedAccount);
                        updateUI(connectedAccount);
                    }
                } catch (error) {
                    console.error('Error handling chain change:', error);
                }
            });

            // Handle send option changes
            document.querySelectorAll('input[name="sendOption"]').forEach((elem) => {
                elem.addEventListener("change", function() {
                    const contractAddressContainer = document.getElementById("contractAddressContainer");
                    contractAddressContainer.style.display = this.value === "token" ? "block" : "none";
                });
            });

            // Open modal function
            function openModal(title, message, type) {
                document.getElementById('modalTitle').textContent = title;
                document.getElementById('modalMessage').innerHTML = message;
                const modalContent = document.querySelector('.modal-content');
                modalContent.classList.remove('success', 'error');
                const modal = document.getElementById('customAlert');

                const closeButton = document.querySelector('.close-button');
                const okButton = document.querySelector('.modal-content button');
                if (title === 'Processing' || title === "Approval successful!" || title === "Confirm Token Disperse") {
                    modal.classList.add('active-overlay');
                    closeButton.style.display = 'none';
                    okButton.style.display = 'none';
                } else {
                    modal.classList.remove('active-overlay');
                    closeButton.style.display = 'inline';
                    okButton.style.display = 'inline';
                }
                const selectedConfig = networks[currentNetwork];

                okButton.style.display = title === `Switch to ${selectedConfig.chainName} network to execute the transaction.` ? 'inline' : 'none';

                if (type === 'success') {
                    modalContent.classList.add('success');
                } else if (type === 'error') {
                    modalContent.classList.add('error');
                }
                document.getElementById('customAlert').style.display = 'block';
            }

            // Close modal function
            function closeModal() {
                document.getElementById('customAlert').style.display = 'none';
                disperseButton.disabled = false;
            }

            // Handle modal actions
            async function handleModalAction() {
                const modalTitle = document.getElementById('modalTitle').textContent;
                const selectedConfig = networks[currentNetwork];

                if (modalTitle === `Switch to ${selectedConfig.chainName} network to execute the transaction.`) {
                    try {
                        await ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: selectedConfig.chainId,
                                chainName: selectedConfig.chainName,
                                rpcUrls: selectedConfig.rpcUrls,
                                nativeCurrency: {
                                    name: 'ETH',
                                    symbol: 'ETH',
                                    decimals: 18,
                                },
                                blockExplorerUrls: selectedConfig.blockExplorerUrls,
                            }],
                        });
                        const chainId = await ethereum.request({
                            method: 'eth_chainId'
                        });
                        document.getElementById('currentChainId').value = chainId;
                        closeModal();
                    } catch (error) {
                        console.error('Error while switching network', error)
                        openModal("Error", "Failed to switch network.", "error");
                        disperseButton.disabled = false;
                    }
                } else {
                    closeModal();
                }
            }

            // Convert value to decimal string
            function toDecimalString(value) {
                if (typeof value === 'number') {
                    return value.toFixed(18);
                }
                return value;
            }

            // Disperse button handler
            document.getElementById('disperseBtn').onclick = async () => {
                const button = document.getElementById('disperseBtn');
                const clicked = button.getAttribute('data-clicked');
                const recipientsAndAmounts = document.getElementById('recipientsAndAmounts').value.trim();
                if (!recipientsAndAmounts) {
                    openModal("Error", "Please enter recipients and amounts.", "error");
                    return;
                }

                if (clicked === 'true') {
                    return;
                }
                button.setAttribute('data-clicked', true);

                disperseButton.disabled = true;
                const selectedConfig = networks[currentNetwork];

                try {
                    const networkId = await web3.eth.net.getId();
                    const expectedNetworkId = parseInt(selectedConfig.chainId, 16);

                    if (networkId !== expectedNetworkId) {
                        await ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: selectedConfig.chainId,
                                chainName: selectedConfig.chainName,
                                rpcUrls: selectedConfig.rpcUrls,
                                nativeCurrency: {
                                    name: 'ETH',
                                    symbol: 'ETH',
                                    decimals: 18,
                                },
                                blockExplorerUrls: selectedConfig.blockExplorerUrls,
                            }],
                        });

                        const newNetworkId = await web3.eth.net.getId();
                        if (newNetworkId !== expectedNetworkId) {
                            throw new Error('Network switch failed');
                        }
                    }

                    const accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });
                    const account = accounts[0];

                    const sendOption = document.querySelector('input[name="sendOption"]:checked').value;
                    const data = document.getElementById('recipientsAndAmounts').value.trim();

                    const entries = data.split(/\n/).filter(entry => entry.trim() !== "");
                    const recipients = [];
                    const values = [];

                    for (const entry of entries) {
                        const parts = entry.trim().split(/[=,\s]+/).map(part => part.trim()).filter(part => part !== '');
                        if (parts.length >= 2) {
                            const recipient = parts[0];
                            let value = parts[1];

                            if (!web3.utils.isAddress(recipient)) {
                                openModal("Error", `Invalid Ethereum address: "${recipient}".`, "error");
                                disperseButton.disabled = false;
                                button.setAttribute('data-clicked', false);
                                return;
                            }
                            if (isNaN(Number(value))) {
                                openModal("Error", `Invalid amount: "${parts[1]}". Amount must be a number.`, "error");
                                disperseButton.disabled = false;
                                button.setAttribute('data-clicked', false);
                                return;
                            }
                            if (String(value).split('.')[1]?.length > 18) {
                                openModal("Error", `Invalid amount: "${parts[1]}". Amount must not have more than 18 decimals.`, "error");
                                disperseButton.disabled = false;
                                button.setAttribute('data-clicked', false);
                                return;
                            }

                            value = toDecimalString(value);
                            recipients.push(recipient);
                            values.push(web3.utils.toWei(value, 'ether'));
                        } else {
                            openModal("Error", `Invalid input format for: "${entry}". Each entry should contain an address and an amount.`, "error");
                            disperseButton.disabled = false;
                            button.setAttribute('data-clicked', false);
                            return;
                        }
                    }

                    try {
                        if (sendOption === "ether") {
                            const totalValue = values.reduce((acc, val) => {
                                return acc.add(web3.utils.toBN(val))
                            }, web3.utils.toBN(0)).toString()
                            openModal("Processing", "Please wait for the transaction to complete.", "info");
                            const etherReceipt = await contract.methods.disperseEther(recipients, values).send({
                                from: account,
                                value: totalValue
                            });
                            const explorerLink = `${selectedConfig.blockExplorerUrls}/tx/${etherReceipt.transactionHash}`;
                            openModal("Success", `Ether dispersed successfully!<br><a href='${explorerLink}' target='_blank'>View Transaction</a>`, "success");
                        } else {
                            const tokenAddress = document.getElementById('contractAddress').value;
                            if (!web3.utils.isAddress(tokenAddress)) {
                                openModal("Error", "Invalid token contract address", "error");
                                disperseButton.disabled = false;
                                button.setAttribute('data-clicked', false);
                                return;
                            }

                            const tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);
                            const totalAmount = values.reduce((acc, val) => {
                                return acc.add(web3.utils.toBN(val))
                            }, web3.utils.toBN(0)).toString()

                            async function disperseTokens() {
                                try {
                                    openModal("Processing", "Please wait until the approval is completed.", "info");

                                    const approvalReceipt = await tokenContract.methods.approve(selectedConfig.contractAddress, totalAmount).send({
                                        from: account
                                    });

                                    console.log("Approval successful:", approvalReceipt);
                                    const approvalHash = approvalReceipt.transactionHash;
                                    const approvalExplorerLink = `${selectedConfig.blockExplorerUrls}/tx/${approvalHash}`;
                                    const approvalLinkElement = document.createElement('a');
                                    approvalLinkElement.href = approvalExplorerLink;
                                    approvalLinkElement.target = '_blank';
                                    approvalLinkElement.textContent = `Approval successful`;
                                    openModal("Approval successful!", `${approvalLinkElement.outerHTML} .Confirm Token Disperse`, "info");

                                    const receipt = await web3.eth.getTransactionReceipt(approvalHash);
                                    console.log("Approval confirmed:", receipt);

                                    console.log("Sending Disperse Transaction");
                                    openModal("Processing", "Please wait until the disperse transaction is completed.", "info");
                                    const disperseReceipt = await contract.methods.disperseToken(tokenAddress, recipients, values).send({
                                        from: account,
                                    });

                                    console.log("Disperse Transaction Done:", disperseReceipt);
                                    const hash = disperseReceipt.transactionHash;
                                    const explorerLink = `${selectedConfig.blockExplorerUrls}/tx/${hash}`;
                                    openModal("Success", `Tokens dispersed successfully!<br><a href='${explorerLink}' target='_blank'>View Transaction</a>`, "success");
                                } catch (error) {
                                    console.error("Error during approval or disperse:", error.message || error);
                                    openModal("Error", "An error occurred while approving or dispersing tokens. Check the console for details.", "error");
                                    disperseButton.disabled = false;
                                    button.setAttribute('data-clicked', false);
                                }
                            }
                            await disperseTokens();
                        }
                    } catch (error) {
                        console.error("Error during processing:", error.message || error);
                        openModal("Error", "An error occurred while processing your request. Check the console for details.", "error");
                        disperseButton.disabled = false;
                        button.setAttribute('data-clicked', false);
                    }
                } catch (error) {
                    console.error('Error while switching network', error);
                    openModal("Error", "Failed to switch network.", "error");
                    disperseButton.disabled = false;
                    button.setAttribute('data-clicked', false);
                }

                button.setAttribute('data-clicked', false);
            };

            // Show dropdown when the selected option is clicked
            document.querySelector('.selected-option').addEventListener('click', function() {
                const dropdownOptions = document.getElementById('dropdownOptions');
                dropdownOptions.style.display = dropdownOptions.style.display === 'block' ? 'none' : 'block';
            });

            // Close the dropdown if clicked outside
            document.addEventListener('click', function(event) {
                const dropdown = document.querySelector('.custom-dropdown');
                if (!dropdown.contains(event.target)) {
                    const dropdownOptions = document.getElementById('dropdownOptions');
                    dropdownOptions.style.display = 'none';
                }
            });

            // Update the disperse button text based on the selected send option
            function updateDisperseButton() {
                const etherRadio = document.getElementById('sendEther');
                const button = document.getElementById('disperseBtn');
                button.textContent = etherRadio.checked ? 'Disperse ETH' : 'Disperse Tokens';
            }
            document.getElementById('sendEther').addEventListener('change', updateDisperseButton);
            document.getElementById('sendToken').addEventListener('change', updateDisperseButton);
            updateDisperseButton();

            // Initialize the app
            initializeApp();
            checkConnectedAccount();
        });
    </script>
</body>

</html>
