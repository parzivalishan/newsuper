<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiSender on Op Sepolia </title>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"></script>
    <style>
        body {
            background-color: #0B0C0E; /* Dark black background for the body */
            color: wheat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        h1, h3 {
            margin: 10px 0;
        }

        button, textarea, input {
            margin: 10px 0;
            padding: 10px;
            width: 300px;
            border: none;
            border-radius: 5px;
        }

        button {
            background-color: #8a2be2;
            color: white;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #7b1fa2;
        }

        button:active {
            background-color: #6a1b9a;
        }

        button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.5);
        }

        textarea {
            height: 150px;
            width: 500px;
            resize: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #e6f7e6;
        }

        .send-options-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .send-options-wrapper h3 {
            margin: 0;
            color: white;
        }

        .option-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            background-color: #1e1e1e;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .option-container:hover {
            border-color: #8a2be2;
            background-color: #2a2a2a;
        }

        .radio-container {
            position: relative;
            margin: 0 10px;
            padding: 10px;
            border-radius: 5px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .radio-container input {
            display: none;
        }

        .radio-label {
            cursor: pointer;
            padding: 10px 20px;
            background-color: #343a40;
            border: 1px solid #444;
            border-radius: 5px;
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }

        .radio-container input:checked + .radio-label {
            background-color: #8a2be2;
            color: white;
            border-color: #8a2be2;
            transform: translateY(-4px);
            box-shadow: 0 6px 12px rgba(138, 43, 226, 0.3);
        }

        .radio-container:hover .radio-label {
            background-color: #444;
            border-color: #8a2be2;
        }

        .contract-address-container {
            display: none;
            margin-top: 10px;
            width: 100%;
            max-width: 500px;
            background: #0B0C0E;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            box-sizing: border-box;
        }

        #contractAddress {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #e6f7e6;
            color: #333;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            box-sizing: border-box;
        }

        #contractAddress:hover, #contractAddress:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }

        header {
            background-color: #0B0C0E;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #balanceDisplay {
            color: white;
            font-weight: bold;
            margin: 0;
        }

        #connectWallet {
            font-weight: bold;
            font-size: 16px;
            background-color: #8a2be2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #connectWallet:hover {
            background-color: #7b1fa2;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #0b0e0c;
            margin: 20% auto;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 400px;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer; /* Enable the close button by default */

        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;

        }

        .success {
            color: green;
        }

        .error {
            color: #FF0000;
        }

        .bold-italic {
            font-weight: bold;
            font-style: italic;
            text-align: center;
        }

          .modal-content button {
            margin-top: 10px; /* Add some margin above the button */
            display: block; /* Make the button fill the width of the modal */
            margin-left: auto;
            margin-right: auto;
            }
    </style>
</head>
<body>

    <header style="background-color: #0B0C0E; padding: 5px 10px; display: flex; justify-content: space-between; align-items: center; width: 100%; position: fixed; top: 0; left: 0; z-index: 1000;">
        <p id="balanceDisplay" style="color: white; font-weight: bold; margin: 0;"></p>
        <button id="connectWallet" style="font-weight: bold; font-size: 16px; background-color: #8a2be2; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin: 0;">
          Connect Wallet
        </button>
      </header>

      <h1 style="margin-top: 70px;">Disperse on OP Sepolia Testnet</h1>

    <p id="walletAddress"></p>

   <div class="send-options-wrapper">
  <h3>Send:</h3>
  <div class="option-container">
    <div class="radio-container">
      <input type="radio" id="sendEther" name="sendOption" value="ether" checked>
      <label for="sendEther" class="radio-label">
        <img src="https://raw.githubusercontent.com/parzivalishan/newsuper/refs/heads/main/assets/eth%20logo.png" alt="Ether Logo" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 5px;">
        <span style="color: white;">Ether</span>
      </label>
    </div>
    <div class="radio-container">
      <input type="radio" id="sendToken" name="sendOption" value="token">
      <label for="sendToken" class="radio-label" style="color: white;">Tokens</label>
    </div>
  </div>
</div>

<div class="contract-address-container" id="contractAddressContainer">
  <input type="text" id="contractAddress" placeholder="Enter token contract address" class="bold-italic" />
</div>

<h3 style="margin-top: 20px; border-top: 1px solid #444; padding-top: 10px; color: white;">
    Recipients and Amounts
  </h3>
    <p>Enter one address and amount in ETH on each line. Supports any format:</p>
    <textarea id="recipientsAndAmounts" placeholder="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 3.141592 0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe,2.7182 0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9=1.42069"></textarea><br>
    
    <button id="disperseBtn" style="font-weight: bold; font-size: 16px;">Disperse ETH</button>

      <div id="customAlert" class="modal" style="display:none;">
        <div class="modal-content">
            <span class="close-button" style="display: none;" onclick="closeModal()">Ã—</span>
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
             <button onclick="closeModal()" style="display:none;">OK</button>
        </div>
    </div>

    <script>
        const contractAddress = "0xD9A438f95D5c0c0A6E09caD70c357328A7360087";
        const contractABI = [
            {
                "constant": false,
                "inputs": [
                    {
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "name": "recipients",
                        "type": "address[]"
                    },
                    {
                        "name": "values",
                        "type": "uint256[]"
                    }
                ],
                "name": "disperseTokenSimple",
                "outputs": [],
                "payable": false,
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "name": "recipients",
                        "type": "address[]"
                    },
                    {
                        "name": "values",
                        "type": "uint256[]"
                    }
                ],
                "name": "disperseToken",
                "outputs": [],
                "payable": false,
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {
                        "name": "recipients",
                        "type": "address[]"
                    },
                    {
                        "name": "values",
                        "type": "uint256[]"
                    }
                ],
                "name": "disperseEther",
                "outputs": [],
                "payable": true,
                "stateMutability": "payable",
                "type": "function"
            }
        ];

        let web3;
        let account;
        let contract;
        let connectedAccount;

        window.addEventListener('load', async () => {
            if (typeof window.ethereum !== 'undefined') {
                web3 = new Web3(window.ethereum);
                contract = new web3.eth.Contract(contractABI, contractAddress);
            } else {
                alert("Please install MetaMask to use this feature.");
            }
        });

        const CHAIN_ID = '0xaa37dc';
        const NETWORK_PARAMS = {
            chainId: CHAIN_ID,
            chainName: 'OP Sepolia',
            rpcUrls: ['https://sepolia.optimism.io/'],
            nativeCurrency: {
                name: 'ETH',
                symbol: 'ETH',
                decimals: 18,
            },
            blockExplorerUrls: ['https://sepolia-optimism.etherscan.io/'],
        };

        document.getElementById('connectWallet').onclick = async () => {
            try {
                const chainId = await ethereum.request({ method: 'eth_chainId' });
                if (chainId !== CHAIN_ID) {
                    await ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [NETWORK_PARAMS],
                    });
                }
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                connectedAccount = accounts[0];
                localStorage.setItem('connectedAccount', connectedAccount);
                updateUI(connectedAccount);

            } catch (error) {
                console.error("Error connecting to wallet:", error);
                openModal("Error", "Failed to connect to wallet. Please try again.", "error");
            }
        };

        const updateUI = async (connectedAccount) => {
            const shortAddress = `${connectedAccount.slice(0, 10)}...${connectedAccount.slice(-8)}`;
            const connectButton = document.getElementById('connectWallet');
            connectButton.textContent = shortAddress;
            connectButton.disabled = true;
            document.getElementById('walletAddress').textContent = `Connected: ${connectedAccount}`;
            const balance = await web3.eth.getBalance(connectedAccount);
            const etherBalance = web3.utils.fromWei(balance, 'ether');
            document.getElementById('balanceDisplay').textContent = `ETH: ${etherBalance}`;
        };

        window.addEventListener('load', async () => {
            const connectedAccount = localStorage.getItem('connectedAccount');
            if (connectedAccount) {
                const accounts = await ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0 && accounts[0] === connectedAccount) {
                    updateUI(connectedAccount);
                } else {
                    localStorage.removeItem('connectedAccount');
                }
            }
        });

        ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length === 0) {
                localStorage.removeItem('connectedAccount');
                document.getElementById('connectWallet').textContent = 'Connect Wallet';
                document.getElementById('connectWallet').disabled = false;
                document.getElementById('walletAddress').textContent = 'Not Connected';
                document.getElementById('balanceDisplay').textContent = 'ETH: 0';
            } else {
                connectedAccount = accounts[0];
                localStorage.setItem('connectedAccount', connectedAccount);
                updateUI(connectedAccount);
            }
        });

        ethereum.on('chainChanged', () => {
            window.location.reload();
        });

        document.querySelectorAll('input[name="sendOption"]').forEach((elem) => {
            elem.addEventListener("change", function() {
                const contractAddressContainer = document.getElementById("contractAddressContainer");
                contractAddressContainer.style.display = this.value === "token" ? "block" : "none";
            });
        });

        const tokenABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "payable": false,
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        function openModal(title, message, type) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').innerHTML = message;
            const modalContent = document.querySelector('.modal-content');
            modalContent.classList.remove('success', 'error');

              const closeButton = document.querySelector('.close-button');
            const okButton =  document.querySelector('.modal-content button');

            // Hide buttons if the title is "Processing", "Approval successful!", or "Confirm Token Disperse"
                if (title === 'Processing' || title === "Approval successful!" || title === "Confirm Token Disperse"){
                     closeButton.style.display = 'none';
                      okButton.style.display = 'none';


                }
                else {
                        closeButton.style.display = 'inline';
                        okButton.style.display = 'inline';

                }

            if (type === 'success') {
                modalContent.classList.add('success');
            } else if (type === 'error') {
                modalContent.classList.add('error');
            }
            document.getElementById('customAlert').style.display = 'block';



        }

        function closeModal() {
            document.getElementById('customAlert').style.display = 'none';
           
        }

        document.getElementById('disperseBtn').onclick = async () => {
            const networkId = await web3.eth.net.getId();
            const expectedNetworkId = 11155420;

            if (networkId !== expectedNetworkId) {
                const userConfirmed = confirm(`Please connect to the Required network (Network ID: ${expectedNetworkId}). Would you like to switch networks?`);
                if (userConfirmed) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: CHAIN_ID }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            try {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [NETWORK_PARAMS],
                                });
                            } catch (addError) {
                                console.error("Error adding network:", addError);
                                openModal("Error", "Failed to add the Required network. Please switch manually.", "error");
                                return;
                            }
                        } else {
                            console.error("Switching network error:", switchError);
                            openModal("Error", "Failed to switch networks. Please switch manually.", "error");
                            return;
                        }
                    }
                } else {
                    return;
                }
            }

            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            const account = accounts[0];

            const sendOption = document.querySelector('input[name="sendOption"]:checked').value;
            const data = document.getElementById('recipientsAndAmounts').value.trim();

            const entries = data.split(/\n/).filter(entry => entry.trim() !== "");
            const recipients = [];
            const values = [];

            for (const entry of entries) {
                const parts = entry.trim().split(/[=,]/).map(part => part.trim());
                if (parts.length >= 2) {
                    const recipient = parts[0];
                    const value = parseFloat(parts[1]);

                    if (!web3.utils.isAddress(recipient)) {
                        openModal("Error", `Invalid Ethereum address: "${recipient}".`, "error");
                        return;
                    }
                    if (isNaN(value)) {
                        openModal("Error", `Invalid amount: "${parts[1]}". Amount must be a number.`, "error");
                        return;
                    }
                    recipients.push(recipient);
                    values.push(web3.utils.toWei(value.toString(), 'ether'));
                } else {
                    openModal("Error", `Invalid input format for: "${entry}". Each entry should contain an address and an amount separated by a comma or equal sign.`, "error");
                    return;
                }
            }

            try {
                if (sendOption === "ether") {
                    const totalValue = web3.utils.toWei(values.reduce((acc, val) => acc + parseFloat(web3.utils.fromWei(val, 'ether')), 0).toString(), 'ether');
                     openModal("Processing", "Please wait for the transaction to complete.", "info");
                    const etherReceipt = await contract.methods.disperseEther(recipients, values).send({
                        from: account,
                        value: totalValue,
                        gas: 300000
                    });
                    const explorerLink = `https://sepolia-optimism.etherscan.io/tx/${etherReceipt.transactionHash}`;
                    openModal("Success", `Ether dispersed successfully!<br><a href='${explorerLink}' target='_blank'>View Transaction</a>`, "success");


                } else {
                    const tokenAddress = document.getElementById('contractAddress').value;
                    if (!web3.utils.isAddress(tokenAddress)) {
                        openModal("Error", "Invalid token contract address", "error");
                        return;
                    }

                    const tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);
                    const totalAmount = values.reduce((acc, val) => acc + parseFloat(web3.utils.fromWei(val, 'ether')), 0);

                    async function disperseTokens() {
                        const button = document.getElementById('disperseBtn');
                        try {
                            button.disabled = true;
                            openModal("Processing", "Please wait until the approval is completed.", "info");

                            const approvalReceipt = await tokenContract.methods.approve(contractAddress, web3.utils.toWei(totalAmount.toString(), 'ether')).send({ from: account });

                            console.log("Approval successful:", approvalReceipt);
                            const approvalHash = approvalReceipt.transactionHash;
                            const approvalExplorerLink = `https://sepolia-optimism.etherscan.io/tx/${approvalHash}`;
                            const approvalLinkElement = document.createElement('a');
                            approvalLinkElement.href = approvalExplorerLink;
                            approvalLinkElement.target = '_blank';
                            approvalLinkElement.textContent = `Approval successful`;
                            openModal("Approval successful!", `${approvalLinkElement.outerHTML} .Confirm Token Disperse`, "info");

                            const receipt = await web3.eth.getTransactionReceipt(approvalHash);
                            console.log("Approval confirmed:", receipt);


                            console.log("Sending Disperse Transaction");
                            openModal("Processing", "Please wait until the disperse transaction is completed.", "info");
                            const disperseReceipt = await contract.methods.disperseToken(tokenAddress, recipients, values).send({
                                from: account,
                                gas: await contract.methods.disperseToken(tokenAddress, recipients, values).estimateGas({ from: account })
                            });


                                 console.log("Disperse Transaction Done:", disperseReceipt);
                            const hash = disperseReceipt.transactionHash;
                            const explorerLink = `https://sepolia-optimism.etherscan.io/tx/${hash}`;
                                openModal("Success", `Tokens dispersed successfully!<br><a href='${explorerLink}' target='_blank'>View Transaction</a>`, "success");



                        } catch (error) {
                            console.error("Error during approval or disperse:", error.message || error);
                            openModal("Error", "An error occurred while approving or dispersing tokens. Check the console for details.", "error");
                        } finally {
                            button.disabled = false;
                        }
                    }
                    await disperseTokens();
                }
            } catch (error) {
                console.error("Error during processing:", error.message || error);
                openModal("Error", "An error occurred while processing your request. Check the console for details.", "error");
            }
        };

        function updateDisperseButton() {
            const etherRadio = document.getElementById('sendEther');
            const button = document.getElementById('disperseBtn');
            button.textContent = etherRadio.checked ? 'Disperse ETH' : 'Disperse Tokens';
        }
        document.getElementById('sendEther').addEventListener('change', updateDisperseButton);
        document.getElementById('sendToken').addEventListener('change', updateDisperseButton);
        updateDisperseButton();
    </script>
</body>
</html>
